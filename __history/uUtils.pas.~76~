unit uUtils;

interface
  uses
    SysUtils, Vcl.Controls, Vcl.Forms, FMX.Edit, Vcl.Graphics,
    FMX.Objects, FMX.Types, FMX.ListBox, uCategoria, FMX.Controls;

  type
    TDataType = (Texto, Inteiro, Moeda, DataHora, DiaMes);
    function ValidarDados(AValue:String; AType:TDataType): Boolean;
    function BoolToInt(AValue:Boolean): Integer;
    function IntToBool(AValue:Integer): Boolean;
    function CurrencyToFloat(AValue:String): Double;
    function StrToCat(AValue:String): TTipoCategoria;
    function CatToStr(AValue:TTipoCategoria): String;
    function CatToStrLegivel(AValue:TTipoCategoria): String;
    function ListBoxItemOf(AComponente: TFmxObject): TListBoxItem;
    procedure ExibirMensagemErro(ACampo: TStyledControl);
    procedure OcultarMensagemErro(Sender: TObject);
    procedure ClearListBox(AListBox: TListBox);
    procedure SetLabelText(ALabel: TText; AText: String);
implementation

procedure SetLabelText(ALabel: TText; AText: String);
begin
  if Assigned(ALabel) then
    ALabel.Text := AText;
end;

procedure ClearListBox(AListBox: TListBox);
var
  i: Integer;
begin
  // Limpa as categorias armazenadas em cada item da ListBox
  for i := 0 to (AListBox.Count - 1) do
    AListBox.ItemByIndex(I).TagObject.Free;

    // Limpa os itens da ListBox
    AListBox.Clear;
end;

function ListBoxItemOf(AComponente: TFmxObject): TListBoxItem;
begin
  // Percorre a hierarquia de componentes até encontrar um TListBoxItem
  while (AComponente <> nil) and not (AComponente is TListBoxItem) do
    AComponente := AComponente.Parent;

  if AComponente is TListBoxItem then
    Result := TListBoxItem(AComponente)
  else
    Result := nil;
end;

function StrToCat(AValue:String): TTipoCategoria;
begin
  if AValue = 'R' then Result := tcReceita
  else Result := tcDespesa
end;

function CatToStr(AValue:TTipoCategoria): String;
begin
  if AValue = tcReceita then Result := 'R'
  else Result := 'D'
end;

function CatToStrLegivel(AValue:TTipoCategoria): String;
begin
  if AValue = tcReceita then Result := 'Receita'
  else Result := 'Despesa'
end;

function CurrencyToFloat(AValue:String): Double;
begin
  var
    CleanText: string;
  begin
    CleanText := StringReplace(AValue, 'R$', '', [rfReplaceAll]);
    CleanText := StringReplace(CleanText, '.', '', [rfReplaceAll]);
    CleanText := StringReplace(CleanText, ' ', '', [rfReplaceAll]);

    Result := StrToFloatDef(CleanText, 0);
  end;
end;

function BoolToInt(AValue:Boolean): Integer;
begin
  if AValue = True then Result := 1
  else Result := 0
end;

function IntToBool(AValue:Integer): Boolean;
begin
  if AValue = 1 then Result := True
  else Result := False
end;

function ValidarDados(AValue:String; AType:TDataType): Boolean;
var
  IntegerNumber: Integer;
  DoubleNumber: Double;
  ValidDate: TDateTime;
begin
  Result := False;

  case AType of
    Texto:
      Result := Trim(AValue) <> '';
    Inteiro:
      Result := TryStrToInt(AValue, IntegerNumber);
    Moeda:
      Result := CurrencyToFloat(AValue) > 0;
    DataHora:
      Result := TryStrToDate(AValue, ValidDate) and (ValidDate > EncodeDate(1899, 12, 30));
    DiaMes:
      Result := TryStrToInt(AValue, IntegerNumber) and (IntegerNumber <= 31);
  end;
end;

procedure ExibirMensagemErro(ACampo: TStyledControl);
var
   TxtError: TText;
begin
  if Assigned(ACampo.TagObject) and (ACampo.TagObject is TText) then
    TxtError := TText(ACampo.TagObject)
  else
  begin
    TxtError := TText.Create(ACampo.Owner);
    TxtError.Parent := ACampo.Parent;
    ACampo.TagObject := TxtError;

    TxtError.TextSettings.Font.Family := 'Montserrat';
    TxtError.TextSettings.Font.Size := 10;
    TxtError.TextSettings.FontColor := $FF952727;
  end;

  TxtError.Text := 'Opa! Insira um valor válido...';
  TxtError.Position.X := ACampo.Position.X;
  TxtError.Position.Y := ACampo.Position.Y + ACampo.Height;
  TxtError.Height := 20;
  TxtError.Width := ACampo.Width * 2;
  TxtError.HorzTextAlign := TTextAlign.Leading;
  TxtError.Visible := True;
end;

end.
